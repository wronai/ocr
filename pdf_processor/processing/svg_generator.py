"""SVG generation utilities for OCR results."""

import base64
import io
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union, Any
from xml.etree import ElementTree as ET

from PIL import Image, ImageDraw, ImageFont
import numpy as np

from ..models.ocr_result import OCRResult, TextBlock
from ..utils.file_utils import get_image_size
from ..utils.logging_utils import setup_logger
from ..utils.validation_utils import validate_positive_number


@dataclass
class SVGConfig:
    """Configuration for SVG generation."""
    # Page settings
    page_width: Optional[float] = None
    page_height: Optional[float] = None
    margin: float = 20.0
    background_color: str = "#ffffff"
    
    # Text layer settings
    text_color: str = "#000000"
    highlight_color: str = "rgba(255, 255, 0, 0.3)"
    font_family: str = "Arial, sans-serif"
    font_size: float = 12.0
    line_height: float = 1.2
    
    # Metadata
    include_metadata: bool = True
    metadata_font_size: float = 10.0
    metadata_color: str = "#666666"
    
    # Interactive elements
    interactive: bool = True
    show_confidence: bool = True
    
    # Debugging
    show_boxes: bool = False
    box_color: str = "rgba(255, 0, 0, 0.5)"
    
    # Watermark
    watermark: Optional[str] = None
    watermark_font_size: float = 48.0
    watermark_color: str = "rgba(0, 0, 0, 0.05)"
    
    # Output
    pretty_print: bool = True
    encoding: str = "utf-8"


class SVGGenerator:
    """Generates SVG files from OCR results."""
    
    def __init__(self, config: Optional[SVGConfig] = None):
        """Initialize the SVG generator.
        
        Args:
            config: Configuration for SVG generation
        """
        self.logger = setup_logger('svg_generator')
        self.config = config or SVGConfig()
        
        # Default font (will be loaded on demand)
        self._default_font = None
    
    def generate_svg(
        self,
        image_path: Union[str, Path],
        ocr_result: OCRResult,
        output_path: Optional[Union[str, Path]] = None,
        **kwargs
    ) -> str:
        """Generate an SVG file from an image and OCR result.
        
        Args:
            image_path: Path to the source image
            ocr_result: OCR result to include in the SVG
            output_path: Path to save the SVG file (optional)
            **kwargs: Override SVGConfig settings
            
        Returns:
            str: The generated SVG as a string
        """
        # Update config with any overrides
        config = self._update_config(kwargs)
        
        # Validate inputs
        image_path = Path(image_path)
        if not image_path.exists():
            raise FileNotFoundError(f"Image file not found: {image_path}")
        
        # Get image dimensions
        img_width, img_height = get_image_size(image_path)
        if config.page_width is None or config.page_height is None:
            config.page_width = img_width
            config.page_height = img_height
        
        # Create SVG root element
        svg_ns = "http://www.w3.org/2000/svg"
        ET.register_namespace('', svg_ns)
        
        # Create root element with proper namespaces
        svg_attribs = {
            'xmlns': svg_ns,
            'width': f"{config.page_width}px",
            'height': f"{config.page_height}px",
            'viewBox': f"0 0 {config.page_width} {config.page_height}",
            'data-original-width': str(img_width),
            'data-original-height': str(img_height)
        }
        
        svg = ET.Element('svg', attrib=svg_attribs)
        
        # Add title and description
        title = ET.SubElement(svg, 'title')
        title.text = f"OCR Result: {image_path.name}"
        
        desc = ET.SubElement(svg, 'desc')
        desc.text = f"OCR result for {image_path.name} generated by PDF OCR Processor"
        
        # Add styles
        self._add_styles(svg, config)
        
        # Add background (optional)
        if config.background_color.lower() != 'none':
            bg = ET.SubElement(svg, 'rect', {
                'x': '0',
                'y': '0',
                'width': '100%',
                'height': '100%',
                'fill': config.background_color
            })
        
        # Add image
        self._add_image(svg, image_path, config)
        
        # Add text blocks
        self._add_text_blocks(svg, ocr_result, config)
        
        # Add metadata (optional)
        if config.include_metadata:
            self._add_metadata(svg, ocr_result, config)
        
        # Add watermark (optional)
        if config.watermark:
            self._add_watermark(svg, config)
        
        # Convert to string
        xml_str = self._tostring(svg, config)
        
        # Save to file if path provided
        if output_path:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w', encoding=config.encoding) as f:
                f.write(xml_str)
            self.logger.info(f"SVG saved to {output_path}")
        
        return xml_str
    
    def _update_config(self, overrides: Dict[str, Any]) -> SVGConfig:
        """Update the configuration with overrides."""
        if not overrides:
            return self.config
        
        # Create a new config with the same values as the current one
        config = SVGConfig(**self.config.__dict__)
        
        # Apply overrides
        for key, value in overrides.items():
            if hasattr(config, key):
                setattr(config, key, value)
        
        return config
    
    def _add_styles(self, parent: ET.Element, config: SVGConfig) -> None:
        """Add CSS styles to the SVG."""
        style = ET.SubElement(parent, 'style')
        style.set('type', 'text/css')
        
        css = """
        /* Text layer */
        .text-layer {
            font-family: %(font_family)s;
            font-size: %(font_size)fpx;
            line-height: %(line_height)f;
            fill: %(text_color)s;
            pointer-events: none;
        }
        
        /* Text blocks */
        .text-block {
            pointer-events: all;
        }
        
        /* Highlight on hover */
        .text-block:hover {
            fill: #ff0000;
            cursor: pointer;
        }
        
        /* Confidence indicator */
        .confidence-indicator {
            fill: %(highlight_color)s;
            opacity: 0.3;
        }
        
        /* Metadata */
        .metadata {
            font-size: %(metadata_font_size)fpx;
            fill: %(metadata_color)s;
            font-family: monospace;
        }
        
        /* Watermark */
        .watermark {
            font-size: %(watermark_font_size)fpx;
            fill: %(watermark_color)s;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
        }
        
        /* Debug boxes */
        .debug-box {
            fill: none;
            stroke: %(box_color)s;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }
        """
        
        # Format the CSS with the config values
        style.text = css % {
            'font_family': config.font_family,
            'font_size': config.font_size,
            'line_height': config.line_height,
            'text_color': config.text_color,
            'highlight_color': config.highlight_color,
            'metadata_font_size': config.metadata_font_size,
            'metadata_color': config.metadata_color,
            'watermark_font_size': config.watermark_font_size,
            'watermark_color': config.watermark_color,
            'box_color': config.box_color
        }
    
    def _add_image(
        self,
        parent: ET.Element,
        image_path: Path,
        config: SVGConfig
    ) -> None:
        """Add the source image to the SVG."""
        try:
            # Read and encode the image
            with open(image_path, 'rb') as f:
                img_data = f.read()
            
            # Get MIME type from file extension
            mime_type = "image/png"
            if image_path.suffix.lower() in ['.jpg', '.jpeg']:
                mime_type = "image/jpeg"
            elif image_path.suffix.lower() == '.gif':
                mime_type = "image/gif"
            
            # Create data URL
            img_b64 = base64.b64encode(img_data).decode('ascii')
            img_url = f"data:{mime_type};base64,{img_b64}"
            
            # Add image element
            ET.SubElement(parent, 'image', {
                'x': '0',
                'y': '0',
                'width': '100%',
                'height': '100%',
                'preserveAspectRatio': 'xMidYMid meet',
                'xlink:href': img_url
            })
            
        except Exception as e:
            self.logger.error(f"Failed to add image to SVG: {e}", exc_info=True)
            # Add a placeholder rectangle if image loading fails
            ET.SubElement(parent, 'rect', {
                'x': '0',
                'y': '0',
                'width': '100%',
                'height': '100%',
                'fill': '#f0f0f0'
            })
    
    def _add_text_blocks(
        self,
        parent: ET.Element,
        ocr_result: OCRResult,
        config: SVGConfig
    ) -> None:
        """Add text blocks from OCR results to the SVG."""
        if not ocr_result.blocks:
            return
        
        # Create a group for all text elements
        text_group = ET.SubElement(parent, 'g', {'class': 'text-layer'})
        
        for i, block in enumerate(ocr_result.blocks):
            if not block.text.strip():
                continue
            
            # Create a group for this text block
            block_attrs = {
                'class': 'text-block',
                'data-confidence': f"{block.confidence:.2f}",
                'data-language': block.language,
                'data-block-id': str(i)
            }
            
            block_group = ET.SubElement(text_group, 'g', block_attrs)
            
            # Add a background rectangle for highlighting (invisible by default)
            if config.interactive:
                ET.SubElement(block_group, 'rect', {
                    'x': str(block.x),
                    'y': str(block.y),
                    'width': str(block.width),
                    'height': str(block.height),
                    'class': 'highlight',
                    'opacity': '0',
                    'rx': '2',
                    'ry': '2'
                })
            
            # Add the text element
            text_elem = ET.SubElement(block_group, 'text', {
                'x': str(block.x + 2),  # Small margin
                'y': str(block.y + config.font_size),  # Baseline adjustment
                'font-size': f"{config.font_size}px",
                'font-family': config.font_family,
                'fill': config.text_color,
                'data-block-id': str(i)
            })
            
            # Add the text content
            text_elem.text = block.text
            
            # Add confidence indicator (optional)
            if config.show_confidence and config.interactive:
                ET.SubElement(block_group, 'rect', {
                    'x': str(block.x),
                    'y': str(block.y + block.height - 2),
                    'width': str(block.width * block.confidence),
                    'height': '2',
                    'class': 'confidence-indicator',
                    'data-confidence': f"{block.confidence:.2f}"
                })
            
            # Add debug bounding box (optional)
            if config.show_boxes:
                ET.SubElement(block_group, 'rect', {
                    'x': str(block.x),
                    'y': str(block.y),
                    'width': str(block.width),
                    'height': str(block.height),
                    'class': 'debug-box',
                    'data-block-id': str(i)
                })
    
    def _add_metadata(
        self,
        parent: ET.Element,
        ocr_result: OCRResult,
        config: SVGConfig
    ) -> None:
        """Add metadata to the SVG."""
        # Create a group for metadata
        meta_group = ET.SubElement(parent, 'g', {'class': 'metadata'})
        
        # Add model and confidence
        meta_text = [
            f"Model: {ocr_result.model}",
            f"Confidence: {ocr_result.confidence:.2f}",
            f"Language: {ocr_result.language}",
            f"Blocks: {len(ocr_result.blocks)}"
        ]
        
        # Add custom metadata if present
        if ocr_result.metadata:
            for key, value in ocr_result.metadata.items():
                meta_text.append(f"{key}: {value}")
        
        # Add metadata text
        for i, line in enumerate(meta_text):
            ET.SubElement(meta_group, 'text', {
                'x': str(config.margin),
                'y': str(config.margin + (i * (config.metadata_font_size * 1.2))),
                'font-size': f"{config.metadata_font_size}px"
            }).text = line
    
    def _add_watermark(
        self,
        parent: ET.Element,
        config: SVGConfig
    ) -> None:
        """Add a watermark to the SVG."""
        if not config.watermark:
            return
        
        # Create a group for the watermark
        watermark = ET.SubElement(parent, 'g', {'class': 'watermark'})
        
        # Add the watermark text
        ET.SubElement(watermark, 'text', {
            'x': '50%',
            'y': '50%',
            'transform': 'rotate(-45, 50%, 50%)',
            'font-size': f"{config.watermark_font_size}px"
        }).text = config.watermark
    
    def _tostring(self, element: ET.Element, config: SVGConfig) -> str:
        """Convert an XML element to a string."""
        # Convert to string
        xml_str = ET.tostring(element, encoding=config.encoding)
        
        # Pretty-print if requested
        if config.pretty_print:
            try:
                from xml.dom import minidom
                dom = minidom.parseString(xml_str)
                xml_str = dom.toprettyxml(encoding=config.encoding)
            except Exception as e:
                self.logger.warning(f"Failed to pretty-print XML: {e}")
        
        # Decode if needed
        if isinstance(xml_str, bytes):
            xml_str = xml_str.decode(config.encoding)
        
        # Remove XML declaration if present (some SVG viewers don't like it)
        xml_str = re.sub(r'^<\?xml[^>]*>\s*', '', xml_str)
        
        return xml_str.strip()
