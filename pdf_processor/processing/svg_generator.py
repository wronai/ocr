"""SVG generation utilities for OCR results."""

import base64
import io
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union, Any
from xml.etree import ElementTree as ET

from PIL import Image, ImageDraw, ImageFont
import numpy as np

from ..models.ocr_result import OCRResult, TextBlock
from ..utils.file_utils import get_image_size
from ..utils.logging_utils import setup_logger
from ..utils.validation_utils import validate_positive_number


@dataclass
class SVGConfig:
    """Configuration for SVG generation."""
    # Page settings
    page_width: Optional[float] = None
    page_height: Optional[float] = None
    margin: float = 20.0
    background_color: str = "#ffffff"
    
    # Text layer settings
    text_color: str = "#000000"
    highlight_color: str = "rgba(255, 255, 0, 0.3)"
    font_family: str = "Arial, sans-serif"
    font_size: float = 12.0
    line_height: float = 1.2
    
    # Metadata
    include_metadata: bool = True
    metadata_font_size: float = 10.0
    metadata_color: str = "#666666"
    
    # Interactive elements
    interactive: bool = True
    show_confidence: bool = True
    
    # Debugging
    show_boxes: bool = False
    box_color: str = "rgba(255, 0, 0, 0.5)"
    
    # Watermark
    watermark: Optional[str] = None
    watermark_font_size: float = 48.0
    watermark_color: str = "rgba(0, 0, 0, 0.05)"
    
    # Output
    pretty_print: bool = True
    encoding: str = "utf-8"


class SVGGenerator:
    """Generates SVG files from OCR results."""
    
    def __init__(self, config: Optional[SVGConfig] = None):
        """Initialize the SVG generator.
        
        Args:
            config: Configuration for SVG generation
        """
        self.logger = setup_logger('svg_generator')
        self.config = config or SVGConfig()
        
        # Default font (will be loaded on demand)
        self._default_font = None
    
    def generate_svg(
        self,
        image_path: Union[str, Path],
        ocr_result: OCRResult,
        output_path: Optional[Union[str, Path]] = None,
        **kwargs
    ) -> str:
        """Generate an SVG file from an image and OCR result.
        
        Args:
            image_path: Path to the source image
            ocr_result: OCR result to include in the SVG
            output_path: Path to save the SVG file (optional)
            **kwargs: Override SVGConfig settings
            
        Returns:
            str: The generated SVG as a string
        """
        # Update config with any overrides
        config = self._update_config(kwargs)
        
        # Validate inputs
        image_path = Path(image_path)
        if not image_path.exists():
            raise FileNotFoundError(f"Image file not found: {image_path}")
        
        # Get image dimensions
        img_width, img_height = get_image_size(image_path)
        if config.page_width is None or config.page_height is None:
            config.page_width = img_width
            config.page_height = img_height
        
        # Create root element with proper namespaces
        svg_ns = "http://www.w3.org/2000/svg"
        xlink_ns = "http://www.w3.org/1999/xlink"
        
        # Register namespaces
        ET.register_namespace('', svg_ns)
        ET.register_namespace('xlink', xlink_ns)
        
        # Create root element with proper namespaces
        svg_attribs = {
            'xmlns': svg_ns,
            'xmlns:xlink': xlink_ns,
            'width': f"{config.page_width}px",
            'height': f"{config.page_height}px",
            'viewBox': f"0 0 {config.page_width} {config.page_height}",
            'data-original-width': str(img_width),
            'data-original-height': str(img_height)
        }
        
        svg = ET.Element('svg', attrib=svg_attribs)
        
        # Add title and description
        title = ET.SubElement(svg, 'title')
        title.text = f"OCR Result: {image_path.name}"
        
        desc = ET.SubElement(svg, 'desc')
        desc.text = f"OCR result for {image_path.name} generated by PDF OCR Processor"
        
        # Add styles
        self._add_styles(svg, config)
        
        # Add background (optional)
        if config.background_color.lower() != 'none':
            bg = ET.SubElement(svg, 'rect', {
                'x': '0',
                'y': '0',
                'width': '100%',
                'height': '100%',
                'fill': config.background_color
            })
        
        # Add image
        self._add_image(svg, image_path, config)
        
        # Add text blocks
        self._add_text_blocks(svg, ocr_result, config)
        
        # Add metadata (optional)
        if config.include_metadata:
            self._add_metadata(svg, ocr_result, config)
        
        # Add watermark (optional)
        if config.watermark:
            self._add_watermark(svg, config)
        
        # Convert to string
        xml_str = self._tostring(svg, config)
        
        # Save to file if path provided
        if output_path:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w', encoding=config.encoding) as f:
                f.write(xml_str)
            self.logger.info(f"SVG saved to {output_path}")
        
        return xml_str
    
    def _update_config(self, overrides: Dict[str, Any]) -> SVGConfig:
        """Update the configuration with overrides."""
        if not overrides:
            return self.config
        
        # Create a new config with the same values as the current one
        config = SVGConfig(**self.config.__dict__)
        
        # Apply overrides
        for key, value in overrides.items():
            if hasattr(config, key):
                setattr(config, key, value)
        
        return config
    
    def _add_styles(self, parent: ET.Element, config: SVGConfig, multi_page: bool = False) -> None:
        """Add CSS styles to the SVG.
        
        Args:
            parent: Parent SVG element to add styles to
            config: SVG configuration
            multi_page: Whether this is a multi-page SVG
        """
        style = ET.SubElement(parent, 'style')
        style.set('type', 'text/css')
        
        # Base styles
        css = """
        /* Base styles */
        * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* Text layer */
        .text-layer {
            font-family: %(font_family)s;
            font-size: %(font_size)fpx;
            line-height: %(line_height)f;
            fill: %(text_color)s;
        }
        
        /* Selectable text */
        .text-block {
            position: absolute;
            white-space: pre;
            cursor: text;
        }
        
        .text-block:hover {
            background-color: %(highlight_color)s;
        }
        
        /* Multi-page specific styles */
        .multi-page-svg {
            display: block;
            margin: 0 auto;
            max-width: 100%%;
            height: auto;
        }
        
        .page {
            display: block;
            margin: 0 auto %(page_spacing)fpx;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        .page:last-child {
            margin-bottom: 0;
        }
        
        .page-image {
            pointer-events: none;
        }
        
        /* Navigation controls */
        .nav-controls {
            font-family: %(font_family)s;
            font-size: 14px;
        }
        
        .nav-button {
            fill: #4a90e2;
            cursor: pointer;
            transition: fill 0.2s;
        }
        
        .nav-button:hover {
            fill: #357abd;
        }
        
        .nav-button-text {
            fill: white;
            font-weight: bold;
            pointer-events: none;
        }
        
        .page-indicator {
            font-size: 14px;
            fill: #333;
        }
        
        /* Metadata */
        .metadata {
            font-family: %(font_family)s;
            font-size: %(metadata_font_size)fpx;
            fill: %(metadata_color)s;
        }
        
        /* Watermark */
        .watermark text {
            font-family: Arial, sans-serif;
            font-size: %(watermark_font_size)fpx;
            fill: %(watermark_color)s;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
        }
        
        /* Debug styles */
        .debug-box {
            fill: none;
            stroke: %(box_color)s;
            stroke-width: 1;
            pointer-events: none;
        }"""
        
        # Add JavaScript for multi-page navigation
        if multi_page:
            css += """
            
            /* Hide all pages except the first one */
            .page:not(:first-child) {
                display: none;
            }
            
            /* Navigation script */
            .nav-script {
                display: none;
            }"""
        
        # Format CSS with config values
        css_vars = {
            'font_family': config.font_family,
            'font_size': config.font_size,
            'line_height': config.line_height,
            'text_color': config.text_color,
            'highlight_color': config.highlight_color,
            'metadata_font_size': config.metadata_font_size,
            'metadata_color': config.metadata_color,
            'watermark_font_size': config.watermark_font_size,
            'watermark_color': config.watermark_color,
            'box_color': config.box_color,
            'page_spacing': getattr(config, 'page_spacing', 20.0)
        }
        
        style.text = css % css_vars
        
        # Add JavaScript for multi-page navigation
        if multi_page:
            script = ET.SubElement(parent, 'script', {
                'type': 'application/ecmascript',
                'class': 'nav-script'
            })
            
            script.text = """
            <![CDATA[
            (function() {
                var currentPage = 1;
                var totalPages = document.querySelectorAll('.page').length;
                var pageIndicator = document.getElementById('page-indicator');
                var prevButton = document.getElementById('prev-button');
                var nextButton = document.getElementById('next-button');
                
                function showPage(pageNum) {
                    // Hide all pages
                    var pages = document.querySelectorAll('.page');
                    for (var i = 0; i < pages.length; i++) {
                        pages[i].style.display = 'none';
                    }
                    
                    // Show the selected page
                    var page = document.getElementById('page-' + pageNum);
                    if (page) {
                        page.style.display = 'block';
                    }
                    
                    // Update page indicator
                    if (pageIndicator) {
                        pageIndicator.textContent = 'Page ' + pageNum + ' of ' + totalPages;
                    }
                    
                    // Update button states
                    if (prevButton) {
                        prevButton.style.opacity = pageNum <= 1 ? '0.5' : '1';
                        prevButton.style.pointerEvents = pageNum <= 1 ? 'none' : 'all';
                    }
                    
                    if (nextButton) {
                        nextButton.style.opacity = pageNum >= totalPages ? '0.5' : '1';
                        nextButton.style.pointerEvents = pageNum >= totalPages ? 'none' : 'all';
                    }
                    
                    // Scroll to top
                    window.scrollTo(0, 0);
                }
                
                // Navigation functions
                function goToPrevPage() {
                    if (currentPage > 1) {
                        currentPage--;
                        showPage(currentPage);
                    }
                }
                
                function goToNextPage() {
                    if (currentPage < totalPages) {
                        currentPage++;
                        showPage(currentPage);
                    }
                }
                
                // Event listeners
                if (prevButton) {
                    prevButton.addEventListener('click', goToPrevPage);
                }
                
                if (nextButton) {
                    nextButton.addEventListener('click', goToNextPage);
                }
                
                // Keyboard navigation
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'ArrowLeft') {
                        goToPrevPage();
                    } else if (e.key === 'ArrowRight') {
                        goToNextPage();
                    }
                });
                
                // Initialize
                showPage(1);
                
                // Make text selectable
                var textBlocks = document.querySelectorAll('.text-block');
                for (var i = 0; i < textBlocks.length; i++) {
                    textBlocks[i].addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                        this.style.userSelect = 'text';
                        this.style.webkitUserSelect = 'text';
                        this.style.MozUserSelect = 'text';
                        this.style.msUserSelect = 'text';
                    });
                    
                    textBlocks[i].addEventListener('mouseup', function() {
                        var selection = window.getSelection();
                        if (selection.toString().length > 0) {
                            document.execCommand('copy');
                        }
                    });
                }
            })();
            ]]>
        </style>
        
        /* Text blocks */
        .text-block {
            pointer-events: all;
        }
        
        /* Highlight on hover */
        .text-block:hover {
            fill: #ff0000;
        }
            cursor: pointer;
        }
        
        /* Confidence indicator */
        .confidence-indicator {
            fill: %(highlight_color)s;
            opacity: 0.3;
        }
        
        /* Metadata */
        .metadata {
            font-size: %(metadata_font_size)fpx;
            fill: %(metadata_color)s;
            font-family: monospace;
        }
        
        /* Watermark */
        .watermark {
            font-size: %(watermark_font_size)fpx;
            fill: %(watermark_color)s;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            user-select: none;
        }
        
        /* Debug boxes */
        .debug-box {
            fill: none;
            stroke: %(box_color)s;
            stroke-width: 1;
            stroke-dasharray: 3,3;
        }
        """
        
        # Format the CSS with the config values
        style.text = css % {
            'font_family': config.font_family,
            'font_size': config.font_size,
            'line_height': config.line_height,
            'text_color': config.text_color,
            'highlight_color': config.highlight_color,
            'metadata_font_size': config.metadata_font_size,
            'metadata_color': config.metadata_color,
            'watermark_font_size': config.watermark_font_size,
            'watermark_color': config.watermark_color,
            'box_color': config.box_color
        }
    
    def _add_image(
        self,
        parent: ET.Element,
        image_path: Path,
        config: SVGConfig
    ) -> None:
        """Add the source image to the SVG."""
        try:
            # Read and encode the image
            with open(image_path, 'rb') as f:
                img_data = f.read()
            
            # Get MIME type from file extension
            mime_type = "image/png"
            if image_path.suffix.lower() in ['.jpg', '.jpeg']:
                mime_type = "image/jpeg"
            elif image_path.suffix.lower() == '.gif':
                mime_type = "image/gif"
            
            # Create data URL
            img_b64 = base64.b64encode(img_data).decode('ascii')
            img_url = f"data:{mime_type};base64,{img_b64}"
            
            # Add image element with proper namespacing
            image_attrs = {
                'x': '0',
                'y': '0',
                'width': '100%',
                'height': '100%',
                'preserveAspectRatio': 'xMidYMid meet',
                '{http://www.w3.org/1999/xlink}href': img_url
            }
            # Add the image element
            ET.SubElement(parent, 'image', image_attrs)
            
        except Exception as e:
            self.logger.error(f"Failed to add image to SVG: {e}", exc_info=True)
            # Add a placeholder rectangle if image loading fails
            ET.SubElement(parent, 'rect', {
                'x': '0',
                'y': '0',
                'width': '100%',
                'height': '100%',
                'fill': '#f0f0f0'
            })
    
    def _add_text_blocks(
        self,
        parent: ET.Element,
        ocr_result: OCRResult,
        config: SVGConfig
    ) -> None:
        """Add text blocks from OCR results to the SVG."""
        if not ocr_result.blocks:
            return
        
        # Create a group for all text elements
        text_group = ET.SubElement(parent, 'g', {'class': 'text-layer'})
        
        for i, block in enumerate(ocr_result.blocks):
            if not block.text.strip():
                continue
            
            # Create a group for this text block
            block_attrs = {
                'class': 'text-block',
                'data-confidence': f"{block.confidence:.2f}",
                'data-language': block.language,
                'data-block-id': str(i)
            }
            
            block_group = ET.SubElement(text_group, 'g', block_attrs)
            
            # Add a background rectangle for highlighting (invisible by default)
            if config.interactive:
                ET.SubElement(block_group, 'rect', {
                    'x': str(block.x),
                    'y': str(block.y),
                    'width': str(block.width),
                    'height': str(block.height),
                    'class': 'highlight',
                    'opacity': '0',
                    'rx': '2',
                    'ry': '2'
                })
            
            # Add the text element
            text_elem = ET.SubElement(block_group, 'text', {
                'x': str(block.x + 2),  # Small margin
                'y': str(block.y + config.font_size),  # Baseline adjustment
                'font-size': f"{config.font_size}px",
                'font-family': config.font_family,
                'fill': config.text_color,
                'data-block-id': str(i)
            })
            
            # Add the text content
            text_elem.text = block.text
            
            # Add confidence indicator (optional)
            if config.show_confidence and config.interactive:
                ET.SubElement(block_group, 'rect', {
                    'x': str(block.x),
                    'y': str(block.y + block.height - 2),
                    'width': str(block.width * block.confidence),
                    'height': '2',
                    'class': 'confidence-indicator',
                    'data-confidence': f"{block.confidence:.2f}"
                })
            
            # Add debug bounding box (optional)
            if config.show_boxes:
                ET.SubElement(block_group, 'rect', {
                    'x': str(block.x),
                    'y': str(block.y),
                    'width': str(block.width),
                    'height': str(block.height),
                    'class': 'debug-box',
                    'data-block-id': str(i)
                })
    
    def _add_metadata(
        self,
        parent: ET.Element,
        ocr_result: OCRResult,
        config: SVGConfig
    ) -> None:
        """Add metadata to the SVG."""
        # Create a group for metadata
        meta_group = ET.SubElement(parent, 'g', {'class': 'metadata'})
        
        # Add model and confidence
        meta_text = [
            f"Model: {ocr_result.model}",
            f"Confidence: {ocr_result.confidence:.2f}",
            f"Language: {ocr_result.language}",
            f"Blocks: {len(ocr_result.blocks)}"
        ]
        
        # Add custom metadata if present
        if ocr_result.metadata:
            for key, value in ocr_result.metadata.items():
                meta_text.append(f"{key}: {value}")
        
        # Add metadata text
        for i, line in enumerate(meta_text):
            ET.SubElement(meta_group, 'text', {
                'x': str(config.margin),
                'y': str(config.margin + (i * (config.metadata_font_size * 1.2))),
                'font-size': f"{config.metadata_font_size}px"
            }).text = line
    
    def _add_watermark(
        self,
        parent: ET.Element,
        config: SVGConfig
    ) -> None:
        """Add a watermark to the SVG."""
        if not config.watermark:
            return
        
        # Create a group for the watermark
        watermark = ET.SubElement(parent, 'g', {'class': 'watermark'})
        
        # Add the watermark text
        ET.SubElement(watermark, 'text', {
            'x': '50%',
            'y': '50%',
            'transform': 'rotate(-45, 50%, 50%)',
            'font-size': f"{config.watermark_font_size}px"
        }).text = config.watermark
    
    def generate_multi_page_svg(
        self,
        pages: List[Dict[str, Any]],
        output_path: Optional[Union[str, Path]] = None,
        **kwargs
    ) -> str:
        """Generate a single SVG file containing multiple pages with navigation.
        
        Args:
            pages: List of page dictionaries, each containing:
                - image_path: Path to the page image
                - ocr_result: OCRResult for the page
                - title: Optional page title (defaults to image filename)
            output_path: Path to save the SVG file (optional)
            **kwargs: Override SVGConfig settings
            
        Returns:
            str: The generated SVG as a string
        """
        # Update config with any overrides
        config = self._update_config(kwargs)
        
        # Calculate total dimensions
        page_width = config.page_width or 800  # Default width if not specified
        page_height = 0
        page_heights = []
        
        # Process each page to get dimensions
        for page in pages:
            img_path = Path(page['image_path'])
            try:
                img_w, img_h = get_image_size(img_path)
                # Maintain aspect ratio
                width_ratio = page_width / img_w
                height = img_h * width_ratio
                page_heights.append(height)
                page_height += height
            except Exception as e:
                self.logger.error(f"Error processing {img_path}: {e}")
                page_heights.append(0)
        
        # Add spacing between pages (10px by default)
        page_spacing = getattr(config, 'page_spacing', 10.0)
        total_spacing = page_spacing * (len(pages) - 1)
        page_height += total_spacing
        
        # Create root element with proper namespaces
        svg_ns = "http://www.w3.org/2000/svg"
        xlink_ns = "http://www.w3.org/1999/xlink"
        
        # Register namespaces
        ET.register_namespace('', svg_ns)
        ET.register_namespace('xlink', xlink_ns)
        
        # Create root element with proper namespaces
        svg_attribs = {
            'xmlns': svg_ns,
            'xmlns:xlink': xlink_ns,
            'width': f"{page_width}px",
            'height': f"{page_height}px",
            'viewBox': f"0 0 {page_width} {page_height}",
            'class': 'multi-page-svg'
        }
        
        svg = ET.Element('svg', attrib=svg_attribs)
        
        # Add title and description
        title = ET.SubElement(svg, 'title')
        title.text = f"Multi-page Document ({len(pages)} pages)"
        
        desc = ET.SubElement(svg, 'desc')
        desc.text = f"Multi-page document with {len(pages)} pages and OCR text"
        
        # Add styles
        self._add_styles(svg, config, multi_page=True)
        
        # Add background
        if config.background_color.lower() != 'none':
            bg = ET.SubElement(svg, 'rect', {
                'x': '0',
                'y': '0',
                'width': '100%',
                'height': '100%',
                'fill': config.background_color
            })
        
        # Add navigation controls
        self._add_navigation_controls(svg, len(pages), page_width, config)
        
        # Add pages
        current_y = 0
        for i, (page, height) in enumerate(zip(pages, page_heights)):
            if height == 0:
                continue
                
            page_group = ET.SubElement(svg, 'g', {
                'class': 'page',
                'id': f'page-{i+1}',
                'data-page': str(i+1)
            })
            
            # Add page background
            ET.SubElement(page_group, 'rect', {
                'x': '0',
                'y': str(current_y),
                'width': str(page_width),
                'height': str(height),
                'fill': 'white',
                'class': 'page-bg'
            })
            
            # Add page image
            img = ET.SubElement(page_group, 'image', {
                'x': '0',
                'y': str(current_y),
                'width': str(page_width),
                'height': str(height),
                'preserveAspectRatio': 'xMidYMid meet',
                'class': 'page-image'
            })
            
            # Add image data
            try:
                with open(page['image_path'], 'rb') as f:
                    img_data = base64.b64encode(f.read()).decode('ascii')
                    img.set('{http://www.w3.org/1999/xlink}href', 
                           f'data:image/png;base64,{img_data}')
            except Exception as e:
                self.logger.error(f"Error embedding image {page['image_path']}: {e}")
            
            # Add text blocks if available
            if 'ocr_result' in page and page['ocr_result'] is not None:
                # Create a group for text at the page's position
                text_group = ET.SubElement(page_group, 'g', {
                    'transform': f'translate(0, {current_y})',
                    'class': 'text-layer'
                })
                self._add_text_blocks(text_group, page['ocr_result'], config)
            
            current_y += height + page_spacing
        
        # Add combined metadata
        if config.include_metadata and any('ocr_result' in p for p in pages):
            self._add_combined_metadata(svg, [p['ocr_result'] for p in pages if 'ocr_result' in p], config)
        
        # Add watermark if specified
        if config.watermark:
            self._add_watermark(svg, config)
        
        # Convert to string
        xml_str = self._tostring(svg, config)
        
        # Save to file if path provided
        if output_path:
            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)
            with open(output_path, 'w', encoding=config.encoding) as f:
                f.write(xml_str)
            self.logger.info(f"Multi-page SVG saved to {output_path}")
        
        return xml_str
    
    def _add_navigation_controls(
        self,
        parent: ET.Element,
        page_count: int,
        page_width: float,
        config: SVGConfig
    ) -> None:
        """Add navigation controls to the SVG."""
        if page_count <= 1:
            return
            
        nav_height = 40
        nav_group = ET.SubElement(parent, 'g', {'class': 'nav-controls'})
        
        # Add navigation background
        ET.SubElement(nav_group, 'rect', {
            'x': '0',
            'y': '0',
            'width': str(page_width),
            'height': str(nav_height),
            'fill': '#f0f0f0',
            'stroke': '#ccc',
            'stroke-width': '1'
        })
        
        # Add previous button
        ET.SubElement(nav_group, 'rect', {
            'x': '10',
            'y': '5',
            'width': '80',
            'height': '30',
            'rx': '4',
            'class': 'nav-button',
            'id': 'prev-button',
            'data-action': 'prev'
        })
        
        ET.SubElement(nav_group, 'text', {
            'x': '50',
            'y': '26',
            'text-anchor': 'middle',
            'class': 'nav-button-text'
        }).text = 'Previous'
        
        # Add next button
        ET.SubElement(nav_group, 'rect', {
            'x': str(page_width - 90),
            'y': '5',
            'width': '80',
            'height': '30',
            'rx': '4',
            'class': 'nav-button',
            'id': 'next-button',
            'data-action': 'next'
        })
        
        ET.SubElement(nav_group, 'text', {
            'x': str(page_width - 50),
            'y': '26',
            'text-anchor': 'middle',
            'class': 'nav-button-text'
        }).text = 'Next'
        
        # Add page indicator
        ET.SubElement(nav_group, 'text', {
            'x': str(page_width / 2),
            'y': '26',
            'text-anchor': 'middle',
            'class': 'page-indicator',
            'id': 'page-indicator'
        }).text = 'Page 1 of {}'.format(page_count)
    
    def _add_combined_metadata(
        self,
        parent: ET.Element,
        ocr_results: List[OCRResult],
        config: SVGConfig
    ) -> None:
        """Add combined metadata from multiple OCR results."""
        if not ocr_results:
            return
            
        meta_group = ET.SubElement(parent, 'g', {
            'class': 'metadata',
            'transform': f'translate(0, 50)'  # Below navigation
        })
        
        # Collect metadata from all pages
        all_metadata = {}
        models = set()
        languages = set()
        
        for i, result in enumerate(ocr_results):
            if result.model:
                models.add(result.model)
            if result.language:
                languages.add(result.language)
            
            if result.metadata:
                for k, v in result.metadata.items():
                    if k not in all_metadata:
                        all_metadata[k] = set()
                    all_metadata[k].add(str(v))
        
        # Add metadata text
        meta_text = [
            f"Document: {len(ocr_results)} pages",
            f"Models: {', '.join(sorted(models))}" if models else "",
            f"Languages: {', '.join(sorted(languages))}" if languages else ""
        ]
        
        # Add combined metadata
        for key, values in sorted(all_metadata.items()):
            meta_text.append(f"{key}: {', '.join(sorted(values))}")
        
        # Add metadata text elements
        for i, line in enumerate(meta_text):
            if not line.strip():
                continue
                
            ET.SubElement(meta_group, 'text', {
                'x': str(config.margin),
                'y': str(20 + (i * (config.metadata_font_size * 1.2))),
                'font-size': f"{config.metadata_font_size}px",
                'class': 'metadata-text'
            }).text = line
    
    def _tostring(self, element: ET.Element, config: SVGConfig) -> str:
        """Convert an XML element to a string with proper namespace handling."""
        # Define namespaces
        namespaces = {
            '': 'http://www.w3.org/2000/svg',
            'xlink': 'http://www.w3.org/1999/xlink'
        }
        
        # Register namespaces for proper serialization
        for prefix, uri in namespaces.items():
            ET.register_namespace(prefix, uri)
        
        # Convert to string with proper namespaces
        xml_str = ET.tostring(element, encoding=config.encoding)
        
        # Pretty-print if requested
        if config.pretty_print:
            try:
                from xml.dom import minidom
                from xml.parsers.expat import ExpatError
                
                # Parse with minidom
                try:
                    dom = minidom.parseString(xml_str)
                    xml_str = dom.toprettyxml(encoding=config.encoding)
                except ExpatError as e:
                    # If pretty printing fails, fall back to unformatted XML
                    self.logger.warning(f"XML parsing error during pretty printing: {e}")
            except Exception as e:
                self.logger.warning(f"Failed to pretty-print XML: {e}")
        
        # Decode if needed
        if isinstance(xml_str, bytes):
            xml_str = xml_str.decode(config.encoding)
        
        # Remove any existing xlink namespace declaration to prevent duplicates
        xml_str = re.sub(r'\s+xmlns:xlink="[^"]*"', '', xml_str)
        # Add the xlink namespace to the root svg element
        xml_str = re.sub(r'<svg([^>]*)>', 
                         r'<svg\1 xmlns:xlink="http://www.w3.org/1999/xlink">', 
                         xml_str, 1)
        
        # Remove XML declaration if present (some SVG viewers don't like it)
        xml_str = re.sub(r'^<\?xml[^>]*>\s*', '', xml_str)
        
        # Ensure proper xlink namespace format
        xml_str = xml_str.replace('ns0:', 'xlink:')
        xml_str = xml_str.replace(':ns0', ':xlink')
        
        # Remove any duplicate attributes (just in case)
        xml_str = re.sub(r'\s+([^\s=]+)="([^"]*)"(?=(?:[^>]*?\s+[^=]+=|"[^"]*"[^>]*>|$))', 
                        r' \1="\2"', xml_str)
        
        return xml_str.strip()
